/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "STM32F103x6.h"
#include "GPIO.h"
#include "EXTI.h"
#include "TIM.h"
#include "PWM.h"
#include "Servo.h"
#include "UltraSonic.h"

#define STM32cube


//#define MAX_SPEED 1000
//#define Target_Val 200
#define MOTOR_PWM 800
#define ARR_Val  1000

uint8_t Motor_Direction = 0;

#ifdef keil
#define CLK 72000000
#define Prescaler_Val  36
#define Prescaler_delay  72
#endif

#ifdef STM32cube
#define CLK 8000000
#define Prescaler_Val  4
#define Prescaler_delay  8
#endif
//*******************************************************
//===================== BLDC Maping ======================
//*******************************************************
#define AH GPIO_PIN_9		//PA9  -> TIM3_CH1
#define AL GPIO_PIN_10		//PA10 -> TIM3_CH2
#define BH GPIO_PIN_11		//PA11 -> TIM1_CH1
#define BL GPIO_PIN_1		//PA1 -> TIM1_CH2
#define CH GPIO_PIN_0		//PA0  -> TIM1_CH3
#define CL GPIO_PIN_3		//PA3  -> TIM1_CH4
//*******************************************************
#define red 	GPIO_PIN_12
#define blue 	GPIO_PIN_13
#define green 	GPIO_PIN_14
//*******************************************************
//===================== HALLL readings ==================
//*******************************************************
uint8_t MOTOR_state =0;     //motor state
uint8_t Hall1_state =0;     //motor state
uint8_t Hall2_state =0;     //motor state
uint8_t Hall3_state =0;     //motor state



//******************************************************
//================ Hall Sensors Functions ==============
//******************************************************
//S1
void S1(){
	Hall1_state = MCAL_GPIO_ReadPin(GPIOA, GPIO_PIN_6);
	//red
	MCAL_GPIO_WritePin(GPIOB, red, Hall1_state);
	//motor direction
	if(Motor_Direction == 0){
		NextStep_FORWARD();
	}
	else {
		NextStep_REVERSE();
	}
}
//S2
void S2(){
	Hall2_state = MCAL_GPIO_ReadPin(GPIOA, GPIO_PIN_7);
	//blue
		MCAL_GPIO_WritePin(GPIOB, blue, Hall2_state);
	//motor direction
	if(Motor_Direction==0){
		NextStep_FORWARD();
	}
	else {
		NextStep_REVERSE();
	}
}
//S3
void S3(){
	Hall3_state = MCAL_GPIO_ReadPin(GPIOA, GPIO_PIN_8);
	//green
	MCAL_GPIO_WritePin(GPIOB, green, Hall3_state);
	//motor direction
	if(Motor_Direction==0){
		NextStep_FORWARD();
	}
	else {
		NextStep_REVERSE();
	}
}

void state (){
	//TClear_irq_Flag(T1);
	switch(MOTOR_state)
	{
	case 0:
		//A floating
		SPWM( GPIOA , AH, ARR_Val , Prescaler_Val , 0 , CLK);
		SPWM( GPIOA , AL, ARR_Val , Prescaler_Val , 0 , CLK);
		//B LOW
		SPWM( GPIOA , BH, ARR_Val , Prescaler_Val , 0 , CLK);
		SPWM( GPIOA , BL, ARR_Val , Prescaler_Val , MOTOR_PWM , CLK);
		//C HIGH
		SPWM( GPIOA , CH, ARR_Val , Prescaler_Val , MOTOR_PWM , CLK);
		SPWM( GPIOA , CL, ARR_Val , Prescaler_Val , 0 , CLK);
		break;
	case 1:
		//A LOW
		SPWM( GPIOA , AH, ARR_Val , Prescaler_Val , 0 , CLK);
		SPWM( GPIOA , AL, 1000 , 4 , MOTOR_PWM , CLK);
		//B HIGH
		SPWM( GPIOA , BH, ARR_Val , Prescaler_Val , MOTOR_PWM , CLK);
		SPWM( GPIOA , BL, ARR_Val , Prescaler_Val , 0 , CLK);
		//C floating
		SPWM( GPIOA , CH, ARR_Val , Prescaler_Val , 0 , CLK);
		SPWM( GPIOA , CL, ARR_Val , Prescaler_Val , 0 , CLK);
		break;
	case 2:
		//A LOW
		SPWM( GPIOA , AH, ARR_Val , Prescaler_Val , 0 , CLK);
		SPWM( GPIOA , AL, ARR_Val , Prescaler_Val , MOTOR_PWM , CLK);
		//B floating
		SPWM( GPIOA , BH, ARR_Val , Prescaler_Val , 0 , CLK);
		SPWM( GPIOA , BL, ARR_Val , Prescaler_Val , 0 , CLK);
		//C HIGH
		SPWM( GPIOA , CH, ARR_Val , Prescaler_Val , MOTOR_PWM , CLK);
		SPWM( GPIOA , CL, ARR_Val , Prescaler_Val , 0 , CLK);
		break;
	case 3:
		//A HIGH
		SPWM( GPIOA , AH, ARR_Val , Prescaler_Val , MOTOR_PWM , CLK);
		SPWM( GPIOA , AL, ARR_Val , Prescaler_Val , 0 , CLK);
		//B floating
		SPWM( GPIOA , BH, ARR_Val , Prescaler_Val , 0 , CLK);
		SPWM( GPIOA , BL, ARR_Val , Prescaler_Val , 0 , CLK);
		//C LOW
		SPWM( GPIOA , CH, ARR_Val , Prescaler_Val , 0 , CLK);
		SPWM( GPIOA , CL, ARR_Val , Prescaler_Val , MOTOR_PWM , CLK);
		break;

	case 4:
		//A HIGH
		SPWM( GPIOA , AH, ARR_Val , Prescaler_Val , MOTOR_PWM , CLK);
		SPWM( GPIOA , AL, ARR_Val , Prescaler_Val , 0 , CLK);
		//B LOW
		SPWM( GPIOA , BH, ARR_Val , Prescaler_Val , 0 , CLK);
		SPWM( GPIOA , BL, ARR_Val , Prescaler_Val , MOTOR_PWM , CLK);
		//C floating
		SPWM( GPIOA , CH, ARR_Val , Prescaler_Val , 0 , CLK);
		SPWM( GPIOA , CL, ARR_Val , Prescaler_Val , 0 , CLK);
		break;
	case 5:
		//A floating
		SPWM( GPIOA , AH, ARR_Val , Prescaler_Val , 0 , CLK);
		SPWM( GPIOA , AL, ARR_Val , Prescaler_Val , 0 , CLK);
		//B HIGH
		SPWM( GPIOA , BH, ARR_Val , Prescaler_Val , MOTOR_PWM , CLK);
		SPWM( GPIOA , BL, ARR_Val , Prescaler_Val , 0 , CLK);
		//C LOW
		SPWM( GPIOA , CH, ARR_Val , Prescaler_Val , 0 , CLK);
		SPWM( GPIOA , CL, ARR_Val , Prescaler_Val , MOTOR_PWM , CLK);
		break;
	}
}

void NextStep_FORWARD() {

	if ((Hall1_state == 0) && (Hall2_state == 0) && (Hall3_state == 1))
		MOTOR_state = 0;

	if ((Hall1_state == 0) && (Hall2_state == 1) && (Hall3_state == 0))
		MOTOR_state = 1;

	if ((Hall1_state == 0) && (Hall2_state == 1) && (Hall3_state == 1))
		MOTOR_state = 2;

	if ((Hall1_state == 1) && (Hall2_state == 0) && (Hall3_state == 0))
		MOTOR_state = 3;

	if ((Hall1_state == 1) && (Hall2_state == 0) && (Hall3_state == 1))
		MOTOR_state = 4;

	if ((Hall1_state == 1) && (Hall2_state == 1) && (Hall3_state == 0))
		MOTOR_state = 5;
	//A floating
	SPWM( GPIOA , AH, ARR_Val , Prescaler_Val , 0 , CLK);
	SPWM( GPIOA , AL, ARR_Val , Prescaler_Val , 0 , CLK);
	//B floating
	SPWM( GPIOA , BH, ARR_Val , Prescaler_Val , 0 , CLK);
	SPWM( GPIOA , BL, ARR_Val , Prescaler_Val , 0 , CLK);
	//C floating
	SPWM( GPIOA , CH, ARR_Val , Prescaler_Val , 0 , CLK);
	SPWM( GPIOA , CL, ARR_Val , Prescaler_Val , 0 , CLK);
	//for Dead Band
	TDelay_Micro(T4, 2, Prescaler_delay );
	
	state();

}
void NextStep_REVERSE() {
	if ((Hall2_state == 0) && (Hall1_state == 0) && (Hall3_state == 1)) {
		MOTOR_state = 0;
	}
	if ((Hall2_state == 0) && (Hall1_state == 1) && (Hall3_state == 0)) {
		MOTOR_state = 1;
	}
	if ((Hall2_state == 0) && (Hall1_state == 1) && (Hall3_state == 1)) {
		MOTOR_state = 2;
	}
	if ((Hall2_state == 1) && (Hall1_state == 0) && (Hall3_state == 0)) {
		MOTOR_state = 3;
	}
	if ((Hall2_state == 1) && (Hall1_state == 0) && (Hall3_state == 1)) {
		MOTOR_state = 4;
	}
	if ((Hall2_state == 1) && (Hall1_state == 1) && (Hall3_state == 0)) {
		MOTOR_state = 5;
	}

	//A floating
	SPWM( GPIOA , AH, ARR_Val , Prescaler_Val , 0 , CLK);
	SPWM( GPIOA , AL, ARR_Val , Prescaler_Val , 0 , CLK);
	//B floating
	SPWM( GPIOA , BH, ARR_Val , Prescaler_Val , 0 , CLK);
	SPWM( GPIOA , BL, ARR_Val , Prescaler_Val , 0 , CLK);
	//C floating
	SPWM( GPIOA , CH, ARR_Val , Prescaler_Val , 0 , CLK);
	SPWM( GPIOA , CL, ARR_Val , Prescaler_Val , 0 , CLK);
	//for Dead Band
	TDelay_Micro(T4, 2, Prescaler_delay );

	state();

}

//===========================     APIs Declaration   =========================//
void Clk_init();
void BLCD_Init();
void S1();
void S2();
void S3();

//==============================================================================

int main(){
	//*****************************************************
	//===================== SYSTEM INIT ===================
	//*****************************************************
	Clk_init();
	//*****************************************************
	//===================== BLDC INIT =====================
	//*****************************************************
	BLCD_Init();
	//==========================================================================

	while(1)
	{

	}
}
	//******************************************************
	//===================== BLDC INIT ======================
	//******************************************************
void BLCD_Init(){
	//*******************************************************
	//================== Control switches  ==================
	//*******************************************************
	GPIO_config_t cl =  {red , GPIO_MODE_OUTPUT_PP ,GPIO_SPEED_10M};
	MCAL_GPIO_Init(GPIOB, &cl);
	GPIO_config_t c2 =  {blue , GPIO_MODE_OUTPUT_PP ,GPIO_SPEED_10M};
	MCAL_GPIO_Init(GPIOB, &c2);
	GPIO_config_t c3 =  {green , GPIO_MODE_OUTPUT_PP ,GPIO_SPEED_10M};
	MCAL_GPIO_Init(GPIOB, &c3);
	//*******************************************************
	//==================== Hall Sensor  =====================
	//*******************************************************
	EXTI_Config_t Hall_1 = { EXTI6PA6, EXTI_IRQ_Enable , EXTI_Trigger_FALLINGAndRISING , S1 };
	MCAL_EXTI_GPIO_Init (&Hall_1);
	EXTI_Config_t Hall_2 = { EXTI7PA7, EXTI_IRQ_Enable , EXTI_Trigger_FALLINGAndRISING , S2 };
	MCAL_EXTI_GPIO_Init (&Hall_2);
	EXTI_Config_t Hall_3 = { EXTI8PA8, EXTI_IRQ_Enable , EXTI_Trigger_FALLINGAndRISING , S3 };
	MCAL_EXTI_GPIO_Init (&Hall_3);
	//********************************************************
	//========= Initialize Hall Sensor readings  =============
	//********************************************************
	S1();
	S2();
	S3();
}
void Clk_init(){
	RCC_GPIOB_CLK_EN();
	RCC_GPIOA_CLK_EN();
}
